线程互斥队列
===============

很多东西因为常用，所以希望将其工具化是一个好办法，比如[线程池][1]，比如本文要写的互斥队列。

互斥队列的应用场景很符合经典[生产者-消费者问题][2]场景，它把生产者-消费者问题的具体化实现为一个队列的数据结构，这样，生产者（若干个）不断将新产品加入到队列中去，消费者（若干个）不断从队列中获取产品来消费掉。这一场景可以在无数的业务中复用起来。

####普通队列的特点
队列满足了FIFO的性质，这样能够满足需要排队处理的业务。只需要关注队列中结点的结构即可。


####互斥队列的特点
1、互斥访问：互斥的目的是保证操作不出错。对队列的push、pop操作这两个影响队列状态的操作加互斥锁。

2、同步访问：同步的目的是保证业务按预定的策略进行。

当队列为空时，消费者的pop行为被阻塞。当生产者push的时候，若有消费者被阻塞，唤醒它。

根据队列的实现的不同，是否存在队列为满的情况？

队列为满的时候，应该如何处理，是抛弃旧结点还是阻塞生产者？


...To be continued



[1]:https://github.com/lucky521/C-Thread-Pool
[2]:http://blog.csdn.net/ojshilu/article/details/24596133
